const std = @import("std");
const log = std.log.scoped(.auth);

const zx = @import("zx");
const js = zx.Client.js;

const api = @import("api");

const wasm = @import("../wasm.zig");

const dialog_id = "auth-dialog";
const submit_id = "submit-button";

const Action = enum {
    signin,
    login,
};

const UserData = struct {
    username: []const u8,
    token: []const u8,
};

var maybe_action: ?Action = null;
var maybe_user_data: ?UserData = null;

fn showForm() void {
    const action = maybe_action orelse {
        log.err("action is null", .{});
        return;
    };

    if (wasm.html.getElementById(dialog_id)) |dialog| {
        defer dialog.deinit();
        dialog.call(void, "showModal", .{}) catch return;
    }

    if (wasm.html.getElementById(submit_id)) |submit| {
        defer submit.deinit();
        const text = switch (action) {
            .signin => "Sign in",
            .login => "Log in",
        };
        submit.set("innerText", js.string(text)) catch return;
    }
}

fn openSignin(_: zx.EventContext) void {
    maybe_action = .signin;
    showForm();
}

fn openLogin(_: zx.EventContext) void {
    maybe_action = .login;
    showForm();
}

fn inCallback(response: api.signin.Response) !void {
    const username = try wasm.allocator.dupe(u8, response.username);
    errdefer wasm.allocator.free(username);

    const token = try wasm.allocator.dupe(u8, response.token);
    errdefer wasm.allocator.free(token);

    maybe_user_data = .{
        .username = username,
        .token = token,
    };
}

fn authenticate(_: zx.EventContext) void {
    const action = maybe_action orelse {
        log.err("action is null", .{})  ;
        return;
    };

    const location: js.Object = js.global.get(js.Object, "location") catch return;
    defer location.deinit();

    const referrer: []const u8 = location.getAlloc(js.String, wasm.allocator, "pathname") catch return;
    defer wasm.allocator.free(referrer);

    const username_input: js.Object = wasm.html.getElementById("username") orelse return;
    defer username_input.deinit();
    const username: []const u8 = username_input.getAlloc(js.String, wasm.allocator, "value") catch return;
    defer wasm.allocator.free(username);

    const password_input: js.Object = wasm.html.getElementById("password") orelse return;
    defer password_input.deinit();
    const password: []const u8 = password_input.getAlloc(js.String, wasm.allocator, "value") catch return;
    defer wasm.allocator.free(password);

    switch (action) {
        .signin => wasm.api.execute(
            api.signin,
            wasm.allocator,
            "/api/signin",
            inCallback,
            .{
                .username = username,
                .password = password,
                .referrer = referrer,
            },
        ) catch return,
        .login => wasm.api.execute(
            api.login,
            wasm.allocator,
            "/api/login",
            inCallback,
            .{
                .username = username,
                .password = password,
                .referrer = referrer,
            },
        ) catch return,
    }
}

fn outCallback(response: api.logout.Response) !void {
    if (response.ok != 1) {
        log.err("API's ok field should always be 1", .{});
        return;
    }

    if (maybe_user_data) |user_data| {
        wasm.allocator.free(user_data.username);
        wasm.allocator.free(user_data.token);
    }

    maybe_user_data = null;
}

fn logout(_: zx.EventContext) void {
    const token = if (maybe_user_data) |user_data| user_data.token else {
        log.err("user_data is null", .{});
        return;
    };

    wasm.api.execute(
        api.logout,
        wasm.allocator,
        "/api/logout",
        outCallback,
        .{
            .token = token,
        },
    ) catch {};
}

fn closeForm(_: zx.EventContext) void {
    maybe_action = null;

    if (wasm.html.getElementById(dialog_id)) |dialog| {
        defer dialog.deinit();
        dialog.call(void, "close", .{}) catch {};
    }

    if (wasm.html.getElementById("username")) |username_input| {
        defer username_input.deinit();
        username_input.set("value", js.string("")) catch {};
    }

    if (wasm.html.getElementById("password")) |password_input| {
        defer password_input.deinit();
        password_input.set("value", js.string("")) catch {};
    }
}

pub fn Buttons(allocator: zx.Allocator) zx.Component {
    if (zx.platform != .browser) return .none;

    const class = "text-primary bg-secondary rounded-md";

    return (
        <div @{allocator}>
            {if (maybe_user_data) |user_data| (
                <>
                    Welcome back, {user_data.username}
                    <button {class} onclick={logout}>Log out</button>
                </>
            ) else (
                <>
                    <button class=`{class} mr-2` onclick={openLogin}>Log in</button>
                    <button {class} onclick={openSignin}>Sign in</button>
                </>
            )}
        </div>
    );
}

pub fn Form(allocator: zx.Allocator) zx.Component {
    if (zx.platform != .browser) return .none;

    return (
        <dialog @{allocator} id={dialog_id} class="backdrop:bg-black/50 rounded-lg ">
            <div class="bg-secondary text-primary rounded-lg shadow-xl p-6 min-w-75 max-w-[95vw]">
                <fieldset>
                    <legend>Username</legend>
                    <input id="username" name="username" type="text" required />
                </fieldset>

                <fieldset>
                    <legend>Password</legend>
                    <input id="password" name="password" type="password" required />
                </fieldset>

                <div class="flex gap-2 mt-4">
                    <button id={submit_id} type="button" onclick={authenticate} class="bg-accent3 rounded-3xl px-4 py-2" />

                    <button type="button" class="bg-gray-500 rounded-3xl px-4 py-2" onclick={closeForm}>
                        Cancel
                    </button>
                </div>
            </div>
        </dialog>
    );
}
