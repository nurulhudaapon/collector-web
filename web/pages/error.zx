const std = @import("std");
const Allocator = std.mem.Allocator;
const log = std.log.scoped(.@"error-handler");

const zx = @import("zx");

const routing = @import("../routing.zig");

fn stackTrace(allocator: std.mem.Allocator) ![]const u8 {
    var text: std.Io.Writer.Allocating = .init(allocator);
    defer text.deinit();

    if (@errorReturnTrace()) |trace| {
        try std.debug.writeStackTrace(
            trace.*,
            &text.writer,
            try std.debug.getSelfDebugInfo(),
            .no_color,
        );
    }

    return text.toOwnedSlice();
}

pub fn Error(ctx: zx.ErrorContext) zx.Component {
    switch (ctx.err) {
        error.NotLoggedIn => {
            return (
                <>
                    Must be logged in to access this page
                </>
            );
        },
        else => {},
    }

    if (routing.isApi(ctx.request.url)) {
        log.err("APIs shouldn't go through pages' processing: {s}", .{ctx.request.url});
    }

    const trace = stackTrace(ctx.arena) catch "";

    return (
        <div @allocator={ctx.arena} class="text-xl">
            <span class="text-accent3">Internal server error: {@errorName(ctx.err)}</span>

            <br />

            {if (routing.getEnvironment(ctx.request) == .development) (
                <>
                    <pre>{trace}</pre>
                    <br />
                </>
            )}

            <a href={ctx.request.url}>Reload page</a>
        </div>
    );
}
