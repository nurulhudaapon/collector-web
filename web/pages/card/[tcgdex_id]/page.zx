const std = @import("std");

const zx = @import("zx");
const js = zx.Client.js;

const api = @import("api");
const app = @import("app");
const database = @import("database");

const cards = @import("../../../components/cards.zx");
const Image = cards.Image;

const wasm = @import("../../../wasm.zig");

// const text = await response.text()
fn onText(text: js.Object) !void {
    const slice = try text.value.string(wasm.allocator);

    const parsed: std.json.Parsed(api.Owned) = try std.json.parseFromSlice(
        api.Owned,
        wasm.allocator,
        slice,
        .{},
    );
    defer parsed.deinit();

    const element: js.Object = .{
        .value = @enumFromInt(parsed.value.js_ref),
    };

    const class_buf = try std.fmt.allocPrint(
        wasm.allocator,
        "{s} {s}",
        .{ "inline-flex items-center px-4 py-2 rounded-md border transition", styleFor(parsed.value.owned) },
    );
    defer wasm.allocator.free(class_buf);

    try element.set("className", js.string(class_buf));
    try element.call(
        void,
        "setAttribute",
        .{
            js.string("base_url"),
            js.string(urlFor(parsed.value.owned)),
        },
    );
}

// const response = await fetch("/api")
fn onResponse(response: js.Object) !void {
    try wasm.text(response, onText);
}

fn toggleOwnedInner(ctx: zx.EventContext) !void {
    const target = ctx.getEvent().getTarget() orelse return;

    const base_url = try target.callAlloc(
        js.String,
        wasm.allocator,
        "getAttribute",
        .{js.string("base_url")},
    );
    defer wasm.allocator.free(base_url);

    const variant_id = try target.callAlloc(
        js.String,
        wasm.allocator,
        "getAttribute",
        .{js.string("variant_id")},
    );
    defer wasm.allocator.free(variant_id);

    const url = try std.fmt.allocPrint(
        wasm.allocator,
        "{s}?variant_id={s}&js_ref={}",
        .{ base_url, variant_id, @intFromEnum(target.value) },
    );
    defer wasm.allocator.free(url);

    try wasm.fetch(url, onResponse);
}

fn toggleOwned(ctx: zx.EventContext) void {
    if (zx.platform != .browser) return;
    toggleOwnedInner(ctx) catch {};
}

fn urlFor(is_owned: bool) []const u8 {
    // NOTE: `/` in URL will be added in onClick's handler
    return if (is_owned)
        "/api/missing"
    else
        "/api/owned";
}

fn styleFor(is_owned: bool) []const u8 {
    return if (is_owned)
        "text-green-600 border-green-300 hover:bg-green-50"
    else
        "text-red-600 border-red-300 hover:bg-red-50";
}

const ButtonProps = struct {
    is_owned: bool,
    text: []const u8,
    variant_id: api.database.Id,
};

pub fn Button(allocator: zx.Allocator, props: ButtonProps) !zx.Component {
    return (
        <button @{allocator} onclick={toggleOwned} class=`inline-flex items-center px-4 py-2 rounded-md border transition {styleFor(props.is_owned)}` base_url={urlFor(props.is_owned)} variant_id={props.variant_id} aria-pressed={if (props.is_owned) "true" else "false"}>
            {props.text}
        </button>
    );
}

pub fn Buttons(
    allocator: zx.Allocator,
    props: struct {
        buttons: []const ButtonProps,
    },
) !zx.Component {
    return (
        <div @allocator={allocator} class="flex flex-col gap-2">
            {for (props.buttons) |button| (
                <div class="w-full">
                    <Button {..button} />
                </div>
            )}
        </div>
    );
}

pub fn Page(ctx: app.PageCtx) !zx.Component {
    const tcgdex_id = ctx.request.getParam("tcgdex_id") orelse return error.MissingTcgdexId;

    var session = try ctx.app.pool.getSession(ctx.arena);
    defer session.deinit();

    const user = try ctx.state.getUser(&session) orelse return error.NotLoggedIn;

    const card = try session
        .query(database.Card)
        .findBy("tcgdex_id", tcgdex_id) orelse return error.UnknownCard;

    const set = try session
        .query(database.Set)
        .findBy("tcgdex_id", card.set_id) orelse return error.UnknovwnSet;

    const variants = try card.getVariants(&session);

    const img_size: cards.ImageSize = .{ .width = .{ .pixels = 320 } };

    const buttons = try ctx.allocator.alloc(ButtonProps, variants.len);
    for (variants, 0..) |variant, i| {
        buttons[i] = .{
            .is_owned = try variant.ownedBy(&session, user.id),
            .variant_id = variant.id,
            .text = try variant.toString(ctx.arena),
        };
    }

    return (
        <div @allocator={ctx.arena} class="max-w-4xl mx-auto p-6">
            <p class="text-4xl font-bold leading-tight">
                {card.name}
            </p>

            <p class="text-sm text-gray-500 mt-2">ID: {card.tcgdex_id} Â· Variants: {variants.len}</p>

            <div class="mt-6 w-full h-full flex flex-col md:flex-row md:items-center gap-8">
                <div class="shrink-0">
                    {if (card.cardmarket_id) |id| (
                        <a href=`https://www.cardmarket.com/Pokemon/Products?idProduct={id}` title="go to cardmarket" class="block shadow-sm rounded-md overflow-hidden">
                            <Image {card} size={img_size} />
                        </a>
                    ) else (
                        <div class="block shadow-sm rounded-md overflow-hidden">
                            <Image {card} size={img_size} />
                        </div>
                    )}

                    <div class="text-sm text-gray-700 mt-2">
                        <p class="mb-0">Set: <a href=`/set/{set.tcgdex_id}` class="text-blue-600 hover:underline">{set.name}</a></p>

                        <div class="mt-4">
                            <a href="/progress" class="inline-flex items-center gap-2 text-sm font-medium text-gray-700 hover:text-gray-300 transition-colors">
                                <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                                </svg>
                                Back to progress
                            </a>
                        </div>
                    </div>
                </div>

                <div class="flex-1">
                    <div class="mb-4">
                        <Buttons @rendering={.client} {buttons} />
                    </div>
                </div>
            </div>
        </div>
    );
}
